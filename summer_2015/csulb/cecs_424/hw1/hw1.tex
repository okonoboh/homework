\documentclass[9pt]{article}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{comment}
\usepackage{fancyhdr}
\usepackage{mathrsfs}
\usepackage{enumitem}


\usepackage{tikz}

\voffset = -50pt
%\textheight = 700pt
\addtolength{\textwidth}{60pt}
\addtolength{\evensidemargin}{-30pt}
\addtolength{\oddsidemargin}{-30pt}
%\setlength{\headheight}{44pt}

\pagestyle{fancy}
\fancyhf{} % clear all fields
\fancyhead[R]{%
  \scshape
  \begin{tabular}[t]{@{}r@{}}
  CECS 424, Summer 2015\\Section 1 (11171)\\
  HW \#1, DUE: 2015, July 13
  \end{tabular}}
\fancyhead[L]{%
  \scshape
  \begin{tabular}[t]{@{}r@{}}
  JOSEPH OKONOBOH\\Computer Science\\Cal State Long Beach
  \end{tabular}}
\fancyfoot[C]{\thepage}

\newcommand{\qed}{\hfill \ensuremath{\Box}}


\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=2pt] (char) {#1};}}

\newcommand{\Z}{\mathbb{Z}}
\newcommand{\I}{\mathbb{I}}
\newcommand{\M}{\mathbb{M}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\D}{\displaystyle}
%\setcounter{section}{-1}

\begin{document}
\noindent Complete these problems on a separate sheet of paper. Due July 14 at
the beginning of lecture.
\begin{enumerate}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%01%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   \item Reading:

         \begin{enumerate}
            \item Chapter 1 intro
            \item \textit{Skim} Chapter 1.1, 1.2, 1.3
            \item Chapter 1.4, 1.6
            \item Chapter 2 intro
            \item Chapter 2.1
            \item Chapter 3 intro
            \item Chapter 3.1, 3.2
         \end{enumerate}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%02%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   \item \textit{Structured programming} is sometimes distinguished from
         \textit{prodecural programming} by the removal of \verb|jump/goto|
         operations found in procedural languages. The \verb|goto| statement has
         received decades of ire from academic and professional computer
         scientists since Edsger Dijkstra's 1968 essay ``Go To Considered
         Harmful." With few exceptions (C++), almost all ``modern" progamming
         languages forbid the use of \verb|goto-|like statements, with some
         languages (Java) going so far as to make \verb|goto| a reserved keyword
         that throws a compile-time error for anyone who attempts to use it.
         However, there remain convincing arguments in favor of using
         \verb|goto| in specificm disciplined ways, and languages without the
         \verb|goto| statement must make other facilities available as 
         alternatives. \\

         In a one- or two-paragraph response, summarize the case for removing
         \verb|goto| statements from structured programming languages. Include
         in your response at least one programming problem whose solution is
         easier using \verb|goto| statements but does not exhibit many of the
         arguments against \verb|goto|. Do you fell the case against \verb|goto|
         is strong enough to ban its inclusion in modern languages?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%03%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   \item Read about the ``goto fail" bug in Apple's iOS/OSX SSL connection
         libraries from 2014. In a one-paragraph response, summarize the error's
         cause, and decide whether you believe the use of \verb|goto| in the
         flawed code was a primary cause of the error. If you blame \verb|goto|,
         demonstrate how to reorganize the code without \verb|goto| to eliminate
         the error; if \verb|goto| is not to blame, describe other programming
         or cultural practices that could have prevented the error being
         published.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%04%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   \item (Exercise 1.1 from \textit{Programming Language Pragmatics}) Using the
         C programming language, give an example of each of the following:

         \begin{enumerate}
            \item A lexical error, detected by the scanner/lexer.
            \item A syntax error, detected by the parser.
            \item A static semantic error, detected by semantic analysis.
            \item A dynamic semantic error, detected by code generated by the
                  compiler.
         \end{enumerate}

      \textbf{Solution.}

      \begin{enumerate}
         \item \begin{verbatim}
1. // There is a lexical error on line 4.
2.
3. int main() {
4.    int 123x = 90;
5.    return 0;
6. }
         \end{verbatim}
         \item \begin{verbatim}
1. // There is a syntax error on line 5.
2
3. int main() {
4.    int x = 90;
5.    = int;
6.    return 0;
7. }
         \end{verbatim}
         \item \begin{verbatim}
1. // There is a static semantic error on line 4.
2.
3. int main() {
4.    int x = "String";
5.    return 0;
6. }
         \end{verbatim}
         \item \begin{verbatim}
1. // There is a dynamic semantic error on line 6.
2.
3. int main() {
4.    int y = 0;
5.    int* z = (int*) y;
6.    *z = 89;
7.    return 0;
8. }
         \end{verbatim}
      \end{enumerate}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%05%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   \item Use the following grammar to draw a parse tree for the expression
         \verb|(3+4)*5:|

         \begin{itemize}
            \item \textit{expr} $\rightarrow$ \textit{term $|$ expr add\_op term}
            \item \textit{term} $\rightarrow$ \textit{factor $|$ term mult\_op 
                  factor}
            \item \textit{factor} $\rightarrow$ \texttt{id $|$  number $|$ - }
                  \textit{factor} $|$ \verb|(|$expr$\verb|)|
            \item \textit{add\_op} $\rightarrow$ \verb|+| $|$ \verb|-|
            \item \textit{mult\_op} $\rightarrow$ \verb|*| $|$ \verb|/|
         \end{itemize}
         
      \textbf{Solution.}
      
      \begin{center}
         \begin{tikzpicture}[scale=3.0]
            %\draw[step=.5cm,gray,very thin] (-2.0,-2.0) grid (2.0, 2.0);
            \draw (0.0,2.0) node {\textit{expr}};
            
            \draw (0.0,1.9) -- (0.0, 1.7);
            
            \draw (0.0,1.6) node {\textit{term}};
            
            \draw (0.0,1.5) -- (-0.5, 1.3);            
            \draw (0.0,1.5) -- (0.0, 1.3);
            \draw (0.0,1.5) -- (0.5, 1.3);
            
            \draw (-0.5,1.2) node {\textit{term}};
            \draw (0.0,1.2) node {\textit{mult\_op}};
            \draw (0.5,1.2) node {\textit{factor}};
            
            \draw (-0.5,1.1) -- (-0.5, 0.9);
            \draw (0.0,1.1) -- (0.0, 0.9);
            \draw (0.5,1.1) -- (0.5, 0.9);
            
            \draw (-0.5,0.8) node {\textit{factor}};
            \draw (0.0,0.8) node {\verb|*|};
            \draw (0.5,0.8) node {\verb|number|};
            
            \draw (-0.5,0.7) -- (-0.5, 0.5);
            \draw (0.5,0.7) -- (0.5, 0.5);
            
            \draw (-0.5,0.5) -- (-1.0, 0.3);
            \draw (-0.5,0.5) -- (-0.5, 0.3);
            \draw (-0.5,0.5) -- (0.0, 0.3);
            \draw (0.5,0.4) node {\verb|5|};
            
            \draw (-1.0,0.2) node {\verb|(|};
            \draw (-0.5,0.2) node {\textit{expr}};
            \draw (0.0,0.2) node {\verb|)|};
            
            \draw (-0.5,0.1) -- (-1.0, -0.1);
            \draw (-0.5,0.1) -- (-0.5, -0.1);
            \draw (-0.5,0.1) -- (0.0, -0.1);
            
            \draw (-1.0, -0.2) node {\textit{expr}};
            \draw (-0.5, -0.2) node {\textit{add\_op}};
            \draw (0.0, -0.2) node {\textit{term}};
            
            \draw (-1.0, -0.3) -- (-1.0, -0.5);
            \draw (-0.5, -0.3) -- (-0.5, -0.5);
            \draw (0.0, -0.3) -- (0.0, -0.5);
            
            \draw (-1.0, -0.6) node {\textit{term}};
            \draw (-0.5, -0.6) node {\verb|+|};
            \draw (0.0, -0.6) node {\textit{factor}};
            
            \draw (-1.0, -0.7) -- (-1.0, -0.9);
            \draw (0.0, -0.7) -- (0.0, -0.9);
            
            \draw (-1.0, -1.0) node {\textit{factor}};
            \draw (0.0, -1.0) node {\verb|number|};
            
            \draw (-1.0, -1.1) -- (-1.0, -1.3);
            \draw (0.0, -1.1) -- (0.0, -1.3);
            
            \draw (-1.0, -1.4) node {\verb|number|};
            \draw (0.0, -1.4) node {\verb|4|};
            
            \draw (-1.0, -1.5) -- (-1.0, -1.7);
            \draw (-1.0, -1.8) node {\verb|3|};
         \end{tikzpicture}
      \end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%06%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   \item Explain in your own words why a language that only supports
         \textit{static allocation} of values cannot support recursive
         functions.
         
      \textbf{Answer.} For recursive functions to execute correctly, then each
      invocation of a particular function call must have its own unshared
      local variables, if any. However, if the language only supports static
      allocation, each successive function invocation in a recursive call will
      overwrite the data of the previous function call, and this may lead to
      logical errors in the program.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%07%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   \item In the following C program, identify one value/object that is allocated
         statically, one that is allocated on the stack, and one that is
         allocated on the heap. Be specific.

         \begin{verbatim}
int global;
int main() {
   scanf("%d", &global); // read an integer form standard in
   int *arr = (int*)malloc(global * sizeof(int)); // allocate an array of the
                                                  // desired size.

   for (int i = 0; i < global; i++) {
      scanf("%d", &arr[i]) // scan in one int for each array location
   }
   return 0;
}
         \end{verbatim}

      \textbf{Answer.}

      $$
         \begin{tabular}{@{}|c|c|@{}} \hline
            Allocation Type & Object \\ \hline
            Static & \verb|global| \\ \hline
            Stack  & \verb|i| \\ \hline
            Heap   & \verb|*arr| \\ \hline
         \end{tabular}
      $$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%08%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   \item Describe what the followng \textit{format specifiers} will print when
         used with the C function \verb|printf|, assuming appropriate values are
         passed as arguments:
         \begin{enumerate}
            \item \verb|%d|
            \item \verb|%s|
            \item \verb|%f|
            \item \verb|%e|
            \item \verb|%%|
         \end{enumerate}

      \textbf{Answer.}

      \begin{enumerate}
         \item The format specifier \verb|%d| will print a signed decimal
               integer.
         \item The format specifier \verb|%s| will print a null terminated
               string.
         \item The format specifier \verb|%f| will print a floating point
               number.
         \item The format specifier \verb|%e| will print a number in scientific
               notation.
         \item The format specifier \verb|%%| will print the literal character
               `\verb|%|'.
      \end{enumerate}
\end{enumerate}
\end{document}
